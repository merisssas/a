name: Super Patcher V19 (Auto-Retry on Corrupt ZIP)

on:
  workflow_dispatch:
    inputs:
      apk_url:
        description: 'Link File (APKS / XAPK Only)'
        required: true
        type: string
        default: 'https://www.mediafire.com/file/wzhnuu6jniby2oo/world.mnetplus_3.38.0.apks/file?dkey=4sagfzcstns&r=1771'

jobs:
  twin-patch-mode:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10' 

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y aapt zipalign apksigner zip unzip
          npm install -g apk-mitm
          pip install cloudscraper requests beautifulsoup4
          
          # Download LSPatch
          wget "https://github.com/LSPosed/LSPatch/releases/download/v0.6/jar-v0.6-398-release.jar" -O lspatch.jar

      - name: Create Certificate & Keystore
        run: |
          printf "%s\n" "-----BEGIN CERTIFICATE-----
          MIIFETCCA/mgAwIBAgIUOkl2iSzmLNvVqAPLtLk5WxAWItAwDQYJKoZIhvcNAQEL
          BQAwgZUxCzAJBgNVBAYTAkNOMREwDwYDVQQIDAhTaGFuZ2hhaTERMA8GA1UEBwwI
          U2hhbmdoYWkxFTATBgNVBAoMDFJlcWFibGUsIExMQzFJMBsGA1UECwwUaHR0cHM6
          Ly9yZXFhYmxlLmNvbS8wKgYDVQQDDCNSZXFhYmxlIENBIChKYW4gMTUsIDIwMjYs
          IDBBQjIyQTI3KTAeFw0yNjAxMTUxMDAxMzJaFw0zMzA1MzEwNTU1NDZaMIGVMQsw
          CQYDVQQGEwJDTjERMA8GA1UECAwIU2hhbmdoYWkxETAPBgNVBAcMCFNoYW5naGFp
          MRUwEwYDVQQKDAxSZXFhYmxlLCBMTEMxSTAbBgNVBAsMFGh0dHBzOi8vcmVxYWJs
          ZS5jb20vMCoGA1UEAwwjUmVxYWJsZSBDQSAoSmFuIDE1LCAyMDI2LCAwQUIyMkEy
          NykwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC9v7wn1vWtLg7bXddE
          CWC58lY+KDqtJINb7aOoObMMKL4sc68+KpTJVTwOsWCnrrLbzPvO5+LEKIOh10IP
          PBDTJBLU3t1OcaReQQic91Yl2MKsrFS9WbW4iRR+BeHtfRMaar+EB23aVMdwx1Uk
          WOlqt5hQaoRbUZnqpgaf+OS2PRHbMHyEPvd3e8pxMkI4V5uSBBdGpdObJuoWUUzf
          VKsgSVDDypbx3eNGKJtc04dZFi+DdGbpfynDgAyTliXbozRuvYOTi17KL1/aLM2K
          GGC1KKdFlXo7sELimlD3TZq7QCrCXdJduJ/qT+aIgrYV8ZIz0OpcXrXjBHhQwlmF
          JlgfAgMBAAGjggFVMIIBUTAdBgNVHQ4EFgQU8pGSM/80EVRYMbfHRefpv2lbZJYw
          HwYDVR0jBBgwFoAU8pGSM/80EVRYMbfHRefpv2lbZJYwDwYDVR0TAQH/BAUwAwEB
          /zAOBgNVHQ8BAf8EBAMCAgQwge0GCWCGSAGG+EIBDQSB3xaB3FRoaXMgUm9vdCBj
          ZXJ0aWZpY2F0ZSB3YXMgZ2VuZXJhdGVkIGJ5IFJlcWFibGUgUHJveHkgZm9yIFNT
          TCBQcm94eWluZy4gSWYgdGhpcyBjZXJ0aWZpY2F0ZSBpcyBwYXJ0IG9mIGEgY2Vy
          dGlmaWNhdGUgY2hhaW4sIHRoaXMgbWVhbnMgdGhhdCB5b3UncmUgYnJvd3Npbmcg
          dGhyb3VnaCBSZXFhYmxlIFByb3h5IHdpdGggU1NMIFByb3h5aW5nIGVuYWJsZWQg
          Zm9yIHRoaXMgd2Vic2l0ZS4wDQYJKoZIhvcNAQELBQADggEBAJBTF1a+EIfxOpi0
          PXhBbNq6LgSLEPFgFms6TByLmKOMgaFhkI74XttYUoe/JPnr7LNDGAZcvmGIv1nq
          5O8vvmzsq3R+moe3GfsU7XlpOnXerdXo0+aCe+KOM6emCqD7fwvKbBmjm54MsZwg
          rp3XQS1mGRirZBNkjKEtLFUdams223C98ohpue7b0CvVxEIfCzhGl4l4sKwOfMz1
          ioqA6JRC56mHKaN8uWO3vWzuEjHOdluWgRVDhtoWzf/V8LNbZHuO0G2nTQw4aNfo
          jTl712YOY5ljPgYFxjT41QEavk3/vY6gDKcX4xpZb0T2xa3QFY7cYjZcU990u66y
          Ff6Xjn0=
          -----END CERTIFICATE-----" > reqable.pem
          
          keytool -genkey -v -keystore debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000 -dname "CN=Android Debug,O=Android,C=US"

      - name: Download Target with Smart Retry
        shell: python
        env:
          APK_URL: ${{ inputs.apk_url }}
        run: |
          import cloudscraper
          import os, sys, time, subprocess
          from bs4 import BeautifulSoup

          def check_integrity(filename):
              print(f"   üîç Verifying ZIP integrity of {filename}...")
              # Jalankan unzip -t -q (quiet test)
              try:
                  result = subprocess.run(["unzip", "-t", "-q", filename], capture_output=True)
                  if result.returncode == 0:
                      print("   ‚úÖ ZIP Integrity PASSED")
                      return True
                  else:
                      print("   ‚ùå ZIP Integrity FAILED (BAD CRC/Header)")
                      return False
              except Exception as e:
                  print(f"   ‚ö†Ô∏è Integrity check error: {e}")
                  return False

          def download_with_retry(url, filename, retries=5):
              scraper = cloudscraper.create_scraper(browser='chrome')
              
              for attempt in range(retries):
                  print(f"üîÑ Attempt {attempt+1}/{retries}...")
                  
                  # 1. Scrape Mediafire if needed
                  target_url = url
                  if 'mediafire.com' in url:
                      try:
                          print("   ...extracting MediaFire link")
                          html = scraper.get(url).text
                          soup = BeautifulSoup(html, 'html.parser')
                          download_btn = soup.find('a', {'id': 'downloadButton'})
                          if download_btn:
                              target_url = download_btn.get('href')
                      except Exception as e:
                          print(f"   ‚ö†Ô∏è Scrape warning: {e}")

                  # 2. Download
                  print(f"   ...downloading from: {target_url[:60]}...")
                  try:
                      with scraper.get(target_url, stream=True, timeout=90) as r:
                          if r.status_code != 200:
                              print(f"   ‚ùå HTTP Status: {r.status_code}")
                              time.sleep(2)
                              continue
                          
                          with open(filename, 'wb') as f:
                              for chunk in r.iter_content(chunk_size=65536): # 64KB chunk
                                  if chunk: f.write(chunk)
                      
                      # 3. Size Check
                      file_size = os.path.getsize(filename)
                      if file_size < 1000000: # 1MB min
                          print("   ‚ö†Ô∏è File too small (likely error page)")
                          os.remove(filename)
                          time.sleep(2)
                          continue

                      # 4. CRITICAL: Integrity Check INSIDE loop
                      if check_integrity(filename):
                          return True
                      else:
                          print("   ‚ôªÔ∏è File corrupted, deleting and retrying...")
                          os.remove(filename)
                          time.sleep(2)
                          continue
                      
                  except Exception as e:
                      print(f"   ‚ùå Error: {e}")
                      time.sleep(2)
              
              return False

          url = os.environ['APK_URL']
          if not download_with_retry(url, "download.apks"):
              print("‚ùå FAILED to download a healthy APKS after multiple attempts.")
              sys.exit(1)

      - name: Download Module with Retry
        shell: python
        run: |
          import cloudscraper
          import os, sys, time
          from bs4 import BeautifulSoup

          def download_with_retry(url, filename, retries=3):
              scraper = cloudscraper.create_scraper(browser='chrome')
              for attempt in range(retries):
                  print(f"üîÑ Attempt {attempt+1}/{retries}...")
                  target_url = url
                  if 'mediafire.com' in url:
                      try:
                          html = scraper.get(url).text
                          soup = BeautifulSoup(html, 'html.parser')
                          btn = soup.find('a', {'id': 'downloadButton'})
                          if btn: target_url = btn.get('href')
                      except: pass
                  
                  try:
                      with scraper.get(target_url, stream=True, timeout=60) as r:
                          if r.status_code != 200: continue
                          with open(filename, 'wb') as f:
                              for chunk in r.iter_content(chunk_size=8192):
                                  if chunk: f.write(chunk)
                      
                      if os.path.getsize(filename) > 10000:
                          print("‚úÖ Module Downloaded")
                          return True
                  except:
                      time.sleep(2)
              return False

          url = "https://www.mediafire.com/file/32gssatb1p4pkbk/Android_Fakers.apk/file?dkey=m7n9sf3hnst&r=1981"
          if not download_with_retry(url, "module.apk"):
              print("‚ùå Failed to download module")
              sys.exit(1)

      - name: Prepare Workspace & Extract
        run: |
          mkdir -p original_workspace workspace_reqable workspace_lspatch
          
          # Unzip is now guaranteed safe because of previous step
          unzip -q download.apks -d original_workspace
          
          # Find base.apk safely (avoiding splits)
          BASE_PATH=$(find original_workspace -type f -name "base.apk" | head -n 1)
          
          # Fallback: if no base.apk, look for largest apk
          if [ -z "$BASE_PATH" ]; then
             echo "‚ö†Ô∏è 'base.apk' not found by name, looking for largest APK..."
             BASE_PATH=$(find original_workspace -name "*.apk" -printf "%s %p\n" | sort -nr | head -1 | awk '{print $2}')
          fi

          if [ -z "$BASE_PATH" ]; then
             echo "‚ùå Error: No APK file found!"
             ls -R original_workspace
             exit 1
          fi
          
          echo "üì¶ Using Base APK: $BASE_PATH"
          cp "$BASE_PATH" workspace_reqable/base.apk
          cp "$BASE_PATH" workspace_lspatch/base.apk
          
          # Copy splits if available
          cp -n original_workspace/*.apk workspace_reqable/ 2>/dev/null || true
          cp -n original_workspace/*.apk workspace_lspatch/ 2>/dev/null || true

      - name: "Mode 1 - Reqable Patching"
        id: reqable
        continue-on-error: true
        run: |
          cd workspace_reqable
          echo "üîµ Patching Reqable..."
          export NODE_OPTIONS="--max-old-space-size=8192"
          
          # Added --skip-signing to prevent internal signer crashes
          apk-mitm base.apk --certificate ../reqable.pem --skip-signing
          
          # Smartly find the output file (patched or unsigned)
          PATCHED_FILE=$(find . -maxdepth 1 \( -name "*-patched.apk" -o -name "*-unsigned.apk" \) | head -n 1)
          
          if [ ! -z "$PATCHED_FILE" ]; then
             echo "‚úÖ Patch success! File: $PATCHED_FILE"
             mv "$PATCHED_FILE" base.apk
             
             for apk in *.apk; do
                echo "üîè Signing $apk..."
                zipalign -p -f -v 4 "$apk" "aligned_$apk"
                mv "aligned_$apk" "$apk"
                apksigner sign --ks ../debug.keystore --ks-pass pass:android "$apk"
             done
             zip -r -q ../Reqable_Version.apks .
             echo "‚úÖ Reqable Artifact Created"
          else
             echo "‚ùå Reqable Patch Failed (No output file detected)"
             exit 1
          fi

      - name: "Mode 2 - LSPatch Patching"
        id: lspatch
        continue-on-error: true
        run: |
          cd workspace_lspatch
          echo "üü£ Patching LSPatch..."
          
          # Added -Xmx2G to prevent Java OOM
          java -Xmx2G -jar ../lspatch.jar base.apk -m ../module.apk -f -l 2
          
          TARGET=$(find . -name "*-lspatched.apk")
          if [ ! -z "$TARGET" ]; then
             echo "‚úÖ Patch success! Found: $TARGET"
             mv "$TARGET" base.apk
             
             for apk in *.apk; do
                echo "üîè Signing $apk..."
                zipalign -p -f -v 4 "$apk" "aligned_$apk"
                mv "aligned_$apk" "$apk"
                apksigner sign --ks ../debug.keystore --ks-pass pass:android "$apk"
             done
             zip -r -q ../LSPatch_Version.apks .
             echo "‚úÖ LSPatch Artifact Created"
          else
             echo "‚ùå LSPatch Failed (Check logs above for Java errors)"
             exit 1
          fi

      - name: Upload Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: Super_Patcher_Results
          path: |
            Reqable_Version.apks
            LSPatch_Version.apks
